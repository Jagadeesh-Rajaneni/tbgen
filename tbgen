#!/usr/bin/awk -f
# tbgen: generate testbench from verilog module
# tbgen is in public domain

BEGIN {
	# variables settable by -v
	if (!tbname)    tbname = "testbench"
	if (!vcdfile)   vcdfile = "testbench.vcd"
	if (!timescale) timescale = 1
	if (!duration)  duration = 100
	if (!step)      step = 1
	if (!module)    module = ""

	# internal variables
	nsteps = duration / step

	for (i = 1; i < ARGC; i++) {
		n = split(ARGV[i], a, ":")
		if (n == 2) {
			inputvalue[a[1]] = a[2]
			inputstep[a[1]] = 1
		} else if (n == 3) {
			inputvalue[a[1]] = a[2]
			inputstep[a[1]] = a[3]
		}
	}
	ARGC = 0

	srand()
}

function abs(n) {
	return n < 0 ? -n : n;
}

function callbc(str, res) {
	cmd = sprintf("echo %c%s%c | bc", 39, str, 39)
	cmd | getline res
	close(cmd)
	return res
}

function getsizestr(str, i, s, n, a, b) {
	for (i in parameters)
		gsub(i, parameters[i], str)
	gsub("[*][*]", "^", str)

	n = split(str, s, "[]:[]")
	if (n == 3) {
		a = callbc(s[2])
		return "[" a "]"
	} else {
		a = callbc(s[2])
		b = callbc(s[3])
		return "[" a ":" b "]"
	}
	print "tbgen: could not compute size of signal bus: " sizestring >"/dev/stderr"
	error = 1
	exit 1
}

function getsizelen(sizestring, len, a) {
	if (sizestring == " ")
		return 1

	len = split(sizestring, a, "[]:[]")
	if (len == 3) {
		return a[2]
	} else if (len == 4) {
		return abs(a[2] - a[3] + 1)
	}
	print "tbgen: could not compute size of signal bus: " sizestring >"/dev/stderr"
	error = 1
	exit 1
}

function randombits(n, i) {
	printf "%s'b", n
	for (i = 0; i < n; i++) {
		if (rand() < 0.5)
			printf "0"
		else
			printf "1"
	}
}

function increasing(n, i) {
	if (reset) {
		Incmax = 1
		for (i = 0; i < n; i++)
			Incmax *= 2
		Incval = 0
		reset = 0
	}

	printf "%s'h%x", n, Incval
	Incval = (Incval + 1) % Incmax
}

function decreasing(n, i) {
	if (reset) {
		Incmax = 1
		for (i = 0; i < n; i++)
			Incmax *= 2
		Incval = Incmax - 1
		reset = 0
	}

	printf "%s'h%x", n, Incval
	if (!Incval)
		Incval = Incmax - 1
	else
		Incval = (Incval - 1) % Incmax
}

function header() {
	print "`timescale " timescale " ns / " timescale " ns"
	print ""
	print "module " tbname "();"
}

function signals(i) {
	for (i in inputs)
		printf "\treg %s %s;\n", inputs[i], i
	for (i in outputs)
		printf "\twire %s %s;\n", outputs[i], i
	print ""
}

function dut(i, a, n) {
	n = 0

	for (i in inputs)
		a[n++] = i
	for (i in outputs)
		a[n++] = i

	printf "\t%s dut(", module
	for (i = 0; i < n; i++)
		printf ".%s(%s)%s", a[i], a[i], (i == n - 1) ? "" : ", "
	printf ");\n\n"
}

function initial() {
	printf "\tinitial\n"
	printf "\tbegin\n"
	printf "\t\t$dumpfile(\"%s\");\n", vcdfile
	printf "\t\t$dumpvars(1, %s);\n", tbname
	printf "\t\t#%s $stop;\n", duration
	printf "\tend\n"
}

function geninput(input, sizelen) {
	reset = 1

	split(input, a, ";")

	printf "\n"
	printf "\t/* %s */\n", a[1]
	printf "\tinitial\n"
	printf "\tbegin\n"

	sizelen = getsizelen(inputs[input])
	if (inputvalue[input] == "r") {
		for (i = 0; i < nsteps / inputstep[input]; i++) {
			printf "\t\t"
			if (i)
				printf "#%s; ", step * inputstep[input]
			printf "%s = ", input
			randombits(sizelen)
			printf ";\n"
		}
	} else if (inputvalue[input] == "i") {
		for (i = 0; i < nsteps / inputstep[input]; i++) {
			printf "\t\t"
			if (i)
				printf "#%s; ", step * inputstep[input]
			printf "%s = ", input
			increasing(sizelen)
			printf ";\n"
		}
	} else if (inputvalue[input] == "d") {
		for (i = 0; i < nsteps / inputstep[input]; i++) {
			printf "\t\t"
			if (i)
				printf "#%s; ", step * inputstep[input]
			printf "%s = ", input
			decreasing(sizelen)
			printf ";\n"
		}
	} else {
		printf "\t\t%s = %s;\n", input, inputvalue[input]
	}

	printf "\tend\n"
}

function footer() {
	print "endmodule"
}

function parameter(str) {
	if (!comment) {
		sub(".*parameter *", "", str)
		gsub("[,=;]", "", str)
		gsub("  *", " ", str)

		n = split(str, a)
		for (i = 1; i <= n; i++) {
			key = a[i]
			parameters[key] = a[++i]
		}
	}
}

{
	gsub("/\\*.*\\*/", "")
}

/\/\*/ {
	comment = 1;
}

/\*\// {
	comment = 0;
}

/`include/ {
	if (!comment) {
		file = $2
		sub("^\"", "", file)
		sub("\"$", "", file)
		while (getline str <file == 1) {
			gsub("/\\*.*\\*/", "", str)
			if (match(str, "parameter")) {
				parameter(str)
			}
		}
		close(file)
	}
}

/^module/ {
	if (!comment) {
		if (module == "") {
			split($0, a, "[ (]")
			module = a[2]
		}
	}
}

/input/ {
	if (!comment) {
		sub(".*input +(wire|reg)? +(unsigned|signed)? *", "", $0)   # remove keywords from $0
		gsub("[,\(\);]", " ", $0)               # remove separators from $0
		gsub("]", "] ", $0)

		n = split($0, a)
		sizestring = " "
		for (i = 1; i <= n; i++) {
			if (match(a[i], "^[[].*")) {
				while (!match(a[i], ".*[]]")) {
					s = a[i++];
					a[i] = s a[i];
				}
			}
			if (match(a[i], "\[[^:]*:?[^\]]*\]"))
				sizestring = getsizestr(a[i++])
			inputs[a[i]] = sizestring
			if (!inputvalue[a[i]])
				inputvalue[a[i]] = "r"
			if (!inputstep[a[i]])
				inputstep[a[i]] = 1
		}
	}
}

/output/ {
	if (!comment) {
		sub(".*output +(wire|reg)? +(unsigned|signed)? *", "", $0)  # remove keywords from $0
		gsub("[,\(\);]", "", $0)                # remove separators from $0
		gsub("]", "] ", $0)

		n = split($0, a)
		sizestring = " "
		for (i = 1; i <= n; i++) {
			if (match(a[i], "^[[].*")) {
				while (!match(a[i], ".*[]]")) {
					s = a[i++];
					a[i] = s a[i];
				}
			}
			if (match(a[i], "\[[^:]*:?[^\]]*\]"))
				sizestring = getsizestr(a[i++])
			outputs[a[i]] = sizestring
		}
	}
}

/parameter/ {
	parameter($0)
}

/endmodule/ {
	if (!comment) {
		exit
	}
}

END {
	if (error)
		exit 1

	header()
	signals()
	dut()
	initial()
	for (input in inputs)
		geninput(input)
	footer()
}
